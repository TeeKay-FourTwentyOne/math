"""
Standalone brute-force validator for R(B_24, B_25) = 99.

Validates the Paley construction over GF(49) = GF(7)[i], i^2 = -1.
This construction uses GF(49) arithmetic (additive group Z_7 x Z_7),
NOT Z_49 circulant arithmetic.

Encoding: element a + bi in GF(49) -> integer a + 7*b (0 <= a,b < 7).

The graph has N = 98 vertices: V1 = {0..48}, V2 = {49..97}.
Adjacency is determined by GF(49) subtraction of the vertex labels
(mod the encoding).

Checks:
1. GF(49) arithmetic correctness (verify i^2 = -1, generator order = 48)
2. QR/QNR sets and structural properties
3. Build full 98x98 adjacency matrix using GF(49) subtraction
4. For EVERY pair (u,v) in C(98,2): count common neighbors, verify thresholds
5. Red edges: common red neighbors <= 23 (avoids B_24)
6. Blue edges: common blue neighbors <= 24 (avoids B_25)

NO dependencies on ramsey_core.py or paley_modified.py - fully self-contained.
"""

import sys
import json
import time
from itertools import combinations


# === GF(49) ARITHMETIC ===
# GF(49) = GF(7)[i] where i^2 = -1 (= 6 mod 7)
# Elements: a + b*i for a,b in {0,...,6}
# Encoding: a + b*i -> a + 7*b (integer 0..48)

def gf49_add(x, y):
    """Add two GF(49) elements (encoded as ints)."""
    a1, b1 = x % 7, x // 7
    a2, b2 = y % 7, y // 7
    return ((a1 + a2) % 7) + 7 * ((b1 + b2) % 7)


def gf49_sub(x, y):
    """Subtract two GF(49) elements: x - y (encoded as ints)."""
    a1, b1 = x % 7, x // 7
    a2, b2 = y % 7, y // 7
    return ((a1 - a2) % 7) + 7 * ((b1 - b2) % 7)


def gf49_neg(x):
    """Negate a GF(49) element: -x."""
    a, b = x % 7, x // 7
    return ((-a) % 7) + 7 * ((-b) % 7)


def gf49_mul(x, y):
    """Multiply two GF(49) elements."""
    a1, b1 = x % 7, x // 7
    a2, b2 = y % 7, y // 7
    # (a1 + b1*i)(a2 + b2*i) = (a1*a2 - b1*b2) + (a1*b2 + b1*a2)*i
    ra = (a1 * a2 - b1 * b2) % 7
    rb = (a1 * b2 + b1 * a2) % 7
    return ra + 7 * rb


def gf49_order(x):
    """Compute multiplicative order of nonzero GF(49) element."""
    if x == 0:
        return 0
    power = x
    for k in range(1, 49):
        if power == 1:  # 1 is encoded as 1 + 0*i = 1
            return k
        power = gf49_mul(power, x)
    return -1


def find_generator():
    """Find a primitive element (generator of GF(49)*)."""
    for x in range(1, 49):
        if gf49_order(x) == 48:
            return x
    return None


def compute_qr_set():
    """Compute quadratic residues in GF(49)*."""
    gen = find_generator()
    assert gen is not None, "No generator found for GF(49)*"

    # QR = {g^(2k) : k = 0,...,23} (even powers)
    powers = []
    power = 1  # g^0 = 1
    for k in range(48):
        powers.append(power)
        power = gf49_mul(power, gen)

    qr = set()
    for k in range(24):
        qr.add(powers[2 * k])

    return gen, qr


def main():
    n = 25
    m = 49  # = 2*25 - 1
    N = 98  # = 2*m

    red_threshold = n - 2   # 23
    blue_threshold = n - 1  # 24

    print("=" * 60)
    print(f"STANDALONE VALIDATOR: R(B_{{24}}, B_{{25}}) = 99")
    print(f"  n = {n}, m = {m}, N = {N}")
    print(f"  Field: GF(49) = GF(7)[i], i^2 = -1")
    print("=" * 60)
    print()

    # === STEP 0: Verify GF(49) arithmetic ===
    print("--- GF(49) Arithmetic Verification ---")

    # Verify i^2 = -1: i is encoded as 0 + 1*i = 7
    i_elem = 7
    i_squared = gf49_mul(i_elem, i_elem)
    neg_one = gf49_neg(1)  # -1 = 6 + 0*i = 6
    print(f"i = {i_elem} (0+1*i), i^2 = {i_squared}, -1 = {neg_one}: "
          f"{'OK' if i_squared == neg_one else 'FAIL'}")

    # Find generator
    gen = find_generator()
    print(f"Generator: {gen} (order = {gf49_order(gen)})")

    # Verify GF(49)* has 48 elements
    all_nonzero = set(range(1, 49))
    powers_set = set()
    power = 1
    for k in range(48):
        powers_set.add(power)
        power = gf49_mul(power, gen)
    print(f"GF(49)* generated by g: |<g>| = {len(powers_set)} (expected 48): "
          f"{'OK' if powers_set == all_nonzero else 'FAIL'}")
    print()

    # === STEP 1: Load and verify construction ===
    print("--- Loading Construction ---")

    # Load from JSON
    json_path = "solution_n25_paley.json"
    try:
        with open(json_path, "r") as f:
            data = json.load(f)
        D11 = data["parameters"]["D11"]
        D12 = data["parameters"]["D12"]
        D22 = data["parameters"]["D22"]
        print(f"Loaded from {json_path}")
    except FileNotFoundError:
        print(f"WARNING: {json_path} not found, computing QR/QNR from scratch")
        _, qr = compute_qr_set()
        D11 = sorted(qr)
        D12 = sorted(qr)
        D22 = sorted(all_nonzero - qr)

    D11_set = set(D11)
    D12_set = set(D12)
    D22_set = set(D22)

    print(f"|D11| = {len(D11)}, |D12| = {len(D12)}, |D22| = {len(D22)}")
    print(f"D11 = {sorted(D11)}")
    print(f"D12 = {sorted(D12)}")
    print(f"D22 = {sorted(D22)}")
    print()

    # === STEP 2: Verify structural properties ===
    print("--- Structural Properties ---")

    structural_ok = True

    # Check cardinalities
    print(f"|D11| = {len(D11)} (expected 24): {'OK' if len(D11) == 24 else 'FAIL'}")
    print(f"|D12| = {len(D12)} (expected 24): {'OK' if len(D12) == 24 else 'FAIL'}")
    print(f"|D22| = {len(D22)} (expected 24): {'OK' if len(D22) == 24 else 'FAIL'}")
    if not (len(D11) == 24 and len(D12) == 24 and len(D22) == 24):
        structural_ok = False

    # D11 symmetric under GF(49) negation
    d11_sym = all(gf49_neg(d) in D11_set for d in D11)
    print(f"D11 symmetric (GF49 negation): {'OK' if d11_sym else 'FAIL'}")
    if not d11_sym:
        structural_ok = False

    # D22 symmetric under GF(49) negation
    d22_sym = all(gf49_neg(d) in D22_set for d in D22)
    print(f"D22 symmetric (GF49 negation): {'OK' if d22_sym else 'FAIL'}")
    if not d22_sym:
        structural_ok = False

    # D22 = complement of D11 in {1,...,48}
    d22_complement = D22_set == all_nonzero - D11_set
    print(f"D22 = complement(D11): {'OK' if d22_complement else 'FAIL'}")
    if not d22_complement:
        structural_ok = False

    # Check 0 not in any diff set (0 is identity, no self-loops)
    no_zero = 0 not in D11_set and 0 not in D22_set
    print(f"0 not in D11, D22: {'OK' if no_zero else 'FAIL'}")
    if not no_zero:
        structural_ok = False

    # NOTE: 0 not in D12 for this Paley construction (differs from Z_m cases)
    print(f"0 in D12: {0 in D12_set} (NOTE: 0 not in D12 for Paley/GF49)")

    # D11 = QR verification: check all elements are quadratic residues
    _, qr = compute_qr_set()
    qr_ints = qr
    d11_is_qr = D11_set == qr_ints
    d12_is_qr = D12_set == qr_ints
    d22_is_qnr = D22_set == (all_nonzero - qr_ints)
    print(f"D11 = QR(GF(49)*): {'OK' if d11_is_qr else 'FAIL'}")
    print(f"D12 = QR(GF(49)*): {'OK' if d12_is_qr else 'FAIL'}")
    print(f"D22 = QNR(GF(49)*): {'OK' if d22_is_qnr else 'FAIL'}")
    if not (d11_is_qr and d12_is_qr and d22_is_qnr):
        structural_ok = False

    # Verify QR has SRG(49, 24, 11, 12) property
    # Paley graph on GF(q), q = 49 â‰¡ 1 (mod 4): strongly regular with
    # Delta(QR, QR, d) = 11 for d in QR, Delta(QR, QR, d) = 12 for d in QNR
    print()
    print("--- Verifying SRG(49, 24, 11, 12) property ---")
    delta_qr_vals = set()
    delta_qnr_vals = set()
    for d in range(1, 49):
        count = sum(1 for a in D11 if gf49_sub(a, d) in D11_set)
        if d in D11_set:
            delta_qr_vals.add(count)
        else:
            delta_qnr_vals.add(count)
    srg_ok = delta_qr_vals == {11} and delta_qnr_vals == {12}
    print(f"Delta(QR, QR, d) for d in QR: {sorted(delta_qr_vals)} (expected {{11}}): "
          f"{'OK' if delta_qr_vals == {11} else 'FAIL'}")
    print(f"Delta(QR, QR, d) for d in QNR: {sorted(delta_qnr_vals)} (expected {{12}}): "
          f"{'OK' if delta_qnr_vals == {12} else 'FAIL'}")
    if not srg_ok:
        structural_ok = False

    # Degrees
    d1 = len(D11) + len(D12)  # 48
    d2 = len(D22) + len(D12)  # 48
    print(f"d1 = {d1}, d2 = {d2}")
    print()

    # === STEP 3: Build full 98x98 adjacency matrix ===
    print("--- Building 98x98 adjacency matrix (GF(49) arithmetic) ---")
    t0 = time.time()

    adj = [[0] * N for _ in range(N)]

    # V1 = {0,...,48}, V2 = {49,...,97}
    for u in range(N):
        for v in range(u + 1, N):
            u_in_V1 = u < m
            v_in_V1 = v < m

            if u_in_V1 and v_in_V1:
                # Both in V1: GF(49) difference
                diff = gf49_sub(v, u)
                if diff in D11_set:
                    adj[u][v] = adj[v][u] = 1
            elif not u_in_V1 and not v_in_V1:
                # Both in V2: map to GF(49) elements, take GF(49) difference
                diff = gf49_sub(v - m, u - m)
                if diff in D22_set:
                    adj[u][v] = adj[v][u] = 1
            else:
                # Cross-block: u in V1, v in V2 (or vice versa)
                if u_in_V1:
                    # u in V1, v in V2: diff = gf49_sub(v - m, u)
                    diff = gf49_sub(v - m, u)
                else:
                    # u in V2, v in V1: diff = gf49_sub(v, u - m)
                    diff = gf49_sub(v, u - m)
                if diff in D12_set:
                    adj[u][v] = adj[v][u] = 1

    t1 = time.time()
    print(f"Adjacency matrix built in {t1 - t0:.2f}s")

    # Verify degree regularity
    deg = [sum(adj[u]) for u in range(N)]
    v1_degs = set(deg[:m])
    v2_degs = set(deg[m:])
    v1_deg_ok = v1_degs == {d1}
    v2_deg_ok = v2_degs == {d2}
    print(f"V1 degrees: {v1_degs} (expected {{{d1}}}): {'OK' if v1_deg_ok else 'FAIL'}")
    print(f"V2 degrees: {v2_degs} (expected {{{d2}}}): {'OK' if v2_deg_ok else 'FAIL'}")
    if not (v1_deg_ok and v2_deg_ok):
        structural_ok = False
    print()

    # === STEP 4: Check ALL C(98, 2) = 4753 pairs ===
    total_pairs = N * (N - 1) // 2
    print(f"--- Checking all C({N}, 2) = {total_pairs} pairs ---")
    t2 = time.time()

    red_edges = 0
    blue_edges = 0
    max_red_cn = 0
    max_blue_cn = 0
    violations = []

    for u, v in combinations(range(N), 2):
        is_red = adj[u][v] == 1

        if is_red:
            red_edges += 1
            cn = 0
            for w in range(N):
                if w != u and w != v and adj[u][w] == 1 and adj[v][w] == 1:
                    cn += 1
            if cn > max_red_cn:
                max_red_cn = cn
            if cn > red_threshold:
                violations.append(("RED", u, v, cn))
        else:
            blue_edges += 1
            cn = 0
            for w in range(N):
                if w != u and w != v and adj[u][w] == 0 and adj[v][w] == 0:
                    cn += 1
            if cn > max_blue_cn:
                max_blue_cn = cn
            if cn > blue_threshold:
                violations.append(("BLUE", u, v, cn))

    t3 = time.time()
    print(f"Pair checking completed in {t3 - t2:.1f}s")
    print()
    print(f"Total pairs checked: {total_pairs}")
    print(f"Red edges: {red_edges}")
    print(f"Blue edges: {blue_edges}")
    print(f"Max red common neighbors:  {max_red_cn} (threshold {red_threshold})")
    print(f"Max blue common neighbors: {max_blue_cn} (threshold {blue_threshold})")
    print(f"Violations: {len(violations)}")

    if violations:
        print()
        print("VIOLATIONS FOUND:")
        for color, u, v, cn in violations[:20]:
            print(f"  {color} edge ({u},{v}): {cn} common neighbors")
        if len(violations) > 20:
            print(f"  ... and {len(violations) - 20} more")

    # === STEP 5: Final verdict ===
    print()
    print("=" * 60)

    passed = structural_ok and len(violations) == 0

    if passed:
        print("RESULT: PASS")
        print()
        print(f"The Paley 2-block graph over GF(49) on {N} vertices contains")
        print(f"no red B_{{24}} and no blue B_{{25}}.")
        print(f"Therefore R(B_{{24}}, B_{{25}}) >= 99.")
        print(f"Combined with the upper bound R(B_{{24}}, B_{{25}}) <= 99,")
        print(f"this proves R(B_{{24}}, B_{{25}}) = 99.")
    else:
        print("RESULT: FAIL")
        if not structural_ok:
            print("  Structural property check failed")
        if violations:
            print(f"  {len(violations)} constraint violation(s)")

    print("=" * 60)
    total_time = time.time() - t0
    print(f"Total validation time: {total_time:.1f}s")

    return passed


if __name__ == "__main__":
    ok = main()
    if not ok:
        sys.exit(1)
